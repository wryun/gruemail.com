export function __vite_legacy_guard() {
  import("data:text/javascript,");
}
;
var NOTIFICATION_BADGE_ICON = "./assets/icon.2a39c64c.png";
const UNHASHED_PRECACHED_ASSETS = ["assets/theme-element.json","index.html"];
const HASHED_PRECACHED_ASSETS = ["assets/icon.2a39c64c.png","assets/icon-maskable.965d12c4.png","assets/download-sandbox.48a866e9.html","assets/olm.92f1ccd0.js","assets/olm.b3e0f9b4.wasm","assets/chevron-down-3300400168.d1a083a1.svg","assets/element-logo-703176763.fc54fc8d.svg","assets/enable-grid-2071838379.ab4f40c5.svg","assets/settings-2175246113.00804666.svg","assets/plus-4190356069.084c5e3d.svg","assets/clear-426756705.361f7a30.svg","assets/chevron-left-3506338632.4e437777.svg","assets/dismiss-2743697487.2f1a17f1.svg","assets/chevron-right-847198822.23380c56.svg","assets/vertical-ellipsis-3416547705.f619a721.svg","assets/send-1171052351.caa5c494.svg","assets/paperclip-2441131778.1f5e29f3.svg","assets/chevron-small-781914114.936b4943.svg","assets/encryption-status-475927392.2fedc0bd.svg","assets/room-members-3847743605.9fcf4567.svg","assets/e2ee-normal-1448349558.af8f5484.svg","assets/e2ee-disabled-1470792300.6863c16d.svg","assets/chevron-thin-left-3831175135.13f60c05.svg","assets/search-3263540198.1511780c.svg","assets/disable-grid-3304422220.8a79cfcb.svg","assets/chevron-down-1956489915.3389f17f.svg","assets/enable-grid-2288309723.f83895c8.svg","assets/element-logo-1551909733.1d59f06a.svg","assets/settings-878939771.57cf3680.svg","assets/plus-3937109722.5c243914.svg","assets/disable-grid-4240599831.c8dc25a1.svg","assets/search-261439583.1bffaca1.svg","assets/clear-4137897294.7b90e8df.svg","assets/chevron-left-2611498805.b5555a61.svg","assets/dismiss-2476348673.d0f98560.svg","assets/chevron-right-2390431650.ec9bf561.svg","assets/vertical-ellipsis-487061581.e7709afd.svg","assets/send-3413346515.b0fb8626.svg","assets/paperclip-3961996319.da562307.svg","assets/chevron-small-4098047679.489e66cc.svg","assets/room-members-3084360280.6f64aaef.svg","assets/encryption-status-3449529405.c200a9bb.svg","assets/chevron-thin-left-3078630092.d0d143e3.svg","assets/index.127d2c93.js","assets/theme-element-light.f1e03c29.css","assets/theme-element-dark.2db3ae06.css","assets/theme-element-runtime.3b22df85.css","assets/chevron-down.9a7440b9.278fe3ed.svg","assets/element-logo.86bc8565.fbdae6e2.svg","assets/enable-grid.eef43c65.a212bb24.svg","assets/settings.45b8e09f.6b788ee4.svg","assets/plus.49560f96.56c67ba2.svg","assets/disable-grid.371ceaaa.4b07635e.svg","assets/search.21e0fd39.0b06ea55.svg","assets/clear.0d180c33.f950be03.svg","assets/chevron-left.b8b2c5fc.14fe1646.svg","assets/chevron-right.885731d1.a7f7fa6c.svg","assets/vertical-ellipsis.70ab5d25.f0a5c761.svg","assets/send.7a090949.a22743f7.svg","assets/paperclip.ec29fd9d.1612f900.svg","assets/chevron-small.dfd7e618.ca2e1d94.svg","assets/room-members.35ed0bf9.033a9a20.svg","assets/encryption-status.8054183e.72d7771f.svg","assets/e2ee-normal.bef76bd4.56fecc05.svg","assets/e2ee-disabled.8507165d.ca72fb6f.svg","assets/chevron-thin-left.d111869b.fea5db89.svg"];
const HASHED_CACHED_ON_REQUEST_ASSETS = ["assets/config.6eeb222f.json","assets/main.3eab263f.js","assets/olm_legacy.9dc48f49.js","assets/Inter-Thin.5d8e2ac4.woff2","assets/Inter-ThinItalic.6b3ded18.woff2","assets/Inter-ExtraLight.da47c335.woff2","assets/Inter-ExtraLightItalic.b3f94cfe.woff2","assets/Inter-Light.0f7dfe72.woff2","assets/Inter-LightItalic.125c7e6a.woff2","assets/Inter-Regular.89d406b0.woff2","assets/Inter-Italic.bab4e808.woff2","assets/Inter-Medium.5d308f3d.woff2","assets/Inter-MediumItalic.76551c20.woff2","assets/Inter-SemiBoldItalic.d376ade4.woff2","assets/Inter-SemiBold.c7c3befe.woff2","assets/Inter-Bold.6f5e9a23.woff2","assets/Inter-BoldItalic.e09dcbe1.woff2","assets/Inter-ExtraBold.0ef4267e.woff2","assets/Inter-ExtraBoldItalic.d1e1f6a0.woff2","assets/Inter-Black.7f1f5616.woff2","assets/Inter-BlackItalic.72d5983b.woff2","assets/Inter-Thin.5565b01e.woff","assets/Inter-ThinItalic.c413497b.woff","assets/Inter-ExtraLight.d7be68a4.woff","assets/Inter-ExtraLightItalic.762fa4d2.woff","assets/Inter-Light.38326098.woff","assets/Inter-LightItalic.ec6c76a8.woff","assets/Inter-Regular.5b3a854b.woff","assets/Inter-Italic.7b187d57.woff","assets/Inter-Medium.0fc5d904.woff","assets/Inter-MediumItalic.1458af9d.woff","assets/Inter-SemiBoldItalic.420db54a.woff","assets/Inter-SemiBold.04cd699f.woff","assets/Inter-Bold.20d46cff.woff","assets/Inter-BoldItalic.31a185fa.woff","assets/Inter-ExtraBold.45bae435.woff","assets/Inter-Black.067c82f7.woff","assets/Inter-ExtraBoldItalic.30a1af87.woff","assets/Inter-BlackItalic.c628a2cf.woff","assets/manifest.56e72e88.json"];
const unhashedCacheName = `hydrogen-assets-${"3389581555"}`;
const hashedCacheName = `hydrogen-assets`;
const mediaThumbnailCacheName = `hydrogen-media-thumbnails-v2`;
self.addEventListener("install", function(e) {
  e.waitUntil((async () => {
    const unhashedCache = await caches.open(unhashedCacheName);
    await unhashedCache.addAll(UNHASHED_PRECACHED_ASSETS);
    const hashedCache = await caches.open(hashedCacheName);
    await Promise.all(HASHED_PRECACHED_ASSETS.map(async (asset) => {
      if (!await hashedCache.match(asset)) {
        await hashedCache.add(asset);
      }
    }));
  })());
});
self.addEventListener("activate", (event) => {
  self.clients.claim();
  event.waitUntil(purgeOldCaches());
});
async function purgeOldCaches() {
  const keyList = await caches.keys();
  for (const key of keyList) {
    if (key !== unhashedCacheName && key !== hashedCacheName && key !== mediaThumbnailCacheName) {
      await caches.delete(key);
    }
  }
  const hashedCache = await caches.open(hashedCacheName);
  const keys = await hashedCache.keys();
  const hashedAssetURLs = HASHED_PRECACHED_ASSETS.concat(HASHED_CACHED_ON_REQUEST_ASSETS).map((a) => new URL(a, self.registration.scope).href);
  for (const request of keys) {
    if (!hashedAssetURLs.some((url) => url === request.url)) {
      hashedCache.delete(request);
    }
  }
}
self.addEventListener("fetch", (event) => {
  if (event.request.method === "GET") {
    event.respondWith(handleRequest(event.request));
  }
});
function isCacheableThumbnail(url) {
  if (url.pathname.startsWith("/_matrix/media/r0/thumbnail/")) {
    const width = parseInt(url.searchParams.get("width"), 10);
    const height = parseInt(url.searchParams.get("height"), 10);
    if (width <= 50 && height <= 50) {
      return true;
    }
  }
  return false;
}
const baseURL = new URL(self.registration.scope);
let pendingFetchAbortController = new AbortController();
async function handleRequest(request) {
  try {
    if (request.url.includes("config.json") || /theme-.+\.json/.test(request.url)) {
      return handleStaleWhileRevalidateRequest(request);
    }
    const url = new URL(request.url);
    if (url.origin === baseURL.origin && url.pathname === baseURL.pathname) {
      request = new Request(new URL("index.html", baseURL.href));
    }
    let response = await readCache(request);
    if (!response) {
      if (isCacheableThumbnail(url)) {
        response = await fetch(request, { signal: pendingFetchAbortController.signal, mode: "cors", credentials: "omit" });
      } else {
        response = await fetch(request, { signal: pendingFetchAbortController.signal });
      }
      await updateCache(request, response);
    }
    return response;
  } catch (err) {
    if (err.name !== "TypeError" && err.name !== "AbortError") {
      console.error("error in service worker", err);
    }
    throw err;
  }
}
async function handleStaleWhileRevalidateRequest(request) {
  let response = await readCache(request);
  const networkResponsePromise = fetchAndUpdateCache(request);
  if (response) {
    return response;
  } else {
    return await networkResponsePromise;
  }
}
async function fetchAndUpdateCache(request) {
  const response = await fetch(request, {
    signal: pendingFetchAbortController.signal,
    headers: {
      "Cache-Control": "no-cache"
    }
  });
  updateCache(request, response.clone());
  return response;
}
async function updateCache(request, response) {
  if (response.status >= 400) {
    return;
  }
  const url = new URL(request.url);
  const baseURL2 = self.registration.scope;
  if (isCacheableThumbnail(url)) {
    const cache = await caches.open(mediaThumbnailCacheName);
    cache.put(request, response.clone());
  } else if (request.url.startsWith(baseURL2)) {
    let assetName = request.url.substr(baseURL2.length);
    let cacheName;
    if (HASHED_CACHED_ON_REQUEST_ASSETS.includes(assetName)) {
      cacheName = hashedCacheName;
    } else if (UNHASHED_PRECACHED_ASSETS.includes(assetName)) {
      cacheName = unhashedCacheName;
    }
    if (cacheName) {
      const cache = await caches.open(cacheName);
      await cache.put(request, response.clone());
    }
  }
}
async function readCache(request) {
  const unhashedCache = await caches.open(unhashedCacheName);
  let response = await unhashedCache.match(request);
  if (response) {
    return response;
  }
  const hashedCache = await caches.open(hashedCacheName);
  response = await hashedCache.match(request);
  if (response) {
    return response;
  }
  const url = new URL(request.url);
  if (isCacheableThumbnail(url)) {
    const mediaThumbnailCache = await caches.open(mediaThumbnailCacheName);
    response = await mediaThumbnailCache.match(request);
    if ((response == null ? void 0 : response.status) >= 400) {
      await mediaThumbnailCache.delete(request);
      response = null;
    }
  }
  return response;
}
self.addEventListener("message", (event) => {
  var _a;
  const reply = (payload) => event.source.postMessage({ replyTo: event.data.id, payload });
  const { replyTo } = event.data;
  if (replyTo) {
    const resolve = pendingReplies.get(replyTo);
    if (resolve) {
      pendingReplies.delete(replyTo);
      resolve(event.data.payload);
    }
  } else {
    switch ((_a = event.data) == null ? void 0 : _a.type) {
      case "version":
        reply({ version: "0.3.3", buildHash: "3389581555" });
        break;
      case "skipWaiting":
        self.skipWaiting();
        break;
      case "haltRequests":
        event.waitUntil(haltRequests().finally(() => reply()));
        break;
      case "closeSession":
        event.waitUntil(closeSession(event.data.payload.sessionId, event.source.id).finally(() => reply()));
        break;
    }
  }
});
const NOTIF_TAG_NEW_MESSAGE = "new_message";
async function openClientFromNotif(event) {
  if (event.notification.tag !== NOTIF_TAG_NEW_MESSAGE) {
    console.log("clicked notif with tag", event.notification.tag);
    return;
  }
  const { sessionId, roomId } = event.notification.data;
  const sessionHash = `#/session/${sessionId}`;
  const roomHash = `${sessionHash}/room/${roomId}`;
  const clientWithSession = await findClient(async (client) => {
    return await sendAndWaitForReply(client, "hasSessionOpen", { sessionId });
  });
  if (clientWithSession) {
    console.log("notificationclick: client has session open, showing room there");
    clientWithSession.postMessage({ type: "openRoom", payload: { roomId } });
    if ("focus" in clientWithSession) {
      try {
        await clientWithSession.focus();
      } catch (err) {
        console.error(err);
      }
    }
  } else if (self.clients.openWindow) {
    console.log("notificationclick: no client found with session open, opening new window");
    const roomURL = new URL(`./${roomHash}`, baseURL).href;
    await self.clients.openWindow(roomURL);
  }
}
self.addEventListener("notificationclick", (event) => {
  event.notification.close();
  event.waitUntil(openClientFromNotif(event));
});
async function handlePushNotification(n) {
  var _a;
  console.log("got a push message", n);
  const sessionId = n.session_id;
  let sender = n.sender_display_name || n.sender;
  if (sender && n.event_id) {
    const roomId = n.room_id;
    const hasFocusedClientOnRoom = !!await findClient(async (client) => {
      if (client.visibilityState === "visible" && client.focused) {
        return await sendAndWaitForReply(client, "hasRoomOpen", { sessionId, roomId });
      }
    });
    if (hasFocusedClientOnRoom) {
      console.log("client is focused, room is open, don't show notif");
      return;
    }
    const newMessageNotifs = Array.from(await self.registration.getNotifications({ tag: NOTIF_TAG_NEW_MESSAGE }));
    const notifsForRoom = newMessageNotifs.filter((n2) => n2.data.roomId === roomId);
    const hasMultiNotification = notifsForRoom.some((n2) => n2.data.multi);
    const hasSingleNotifsForRoom = newMessageNotifs.some((n2) => !n2.data.multi);
    const roomName = n.room_name || n.room_alias;
    let multi = false;
    let label;
    let body;
    if (hasMultiNotification) {
      console.log("already have a multi message, don't do anything");
      return;
    } else if (hasSingleNotifsForRoom) {
      console.log("showing multi message notification");
      multi = true;
      label = roomName || sender;
      body = "New messages";
    } else {
      console.log("showing new message notification");
      if (roomName && roomName !== sender) {
        label = `${sender} in ${roomName}`;
      } else {
        label = sender;
      }
      body = ((_a = n.content) == null ? void 0 : _a.body) || "New message";
    }
    await self.registration.showNotification(label, {
      body,
      data: { sessionId, roomId, multi },
      tag: NOTIF_TAG_NEW_MESSAGE,
      badge: NOTIFICATION_BADGE_ICON
    });
  }
}
self.addEventListener("push", (event) => {
  event.waitUntil(handlePushNotification(event.data.json()));
});
async function closeSession(sessionId, requestingClientId) {
  const clients = await self.clients.matchAll();
  await Promise.all(clients.map(async (client) => {
    if (client.id !== requestingClientId) {
      await sendAndWaitForReply(client, "closeSession", { sessionId });
    }
  }));
}
async function haltRequests() {
  const clients = await self.clients.matchAll({ type: "window" });
  await Promise.all(clients.map((client) => {
    return sendAndWaitForReply(client, "haltRequests");
  }));
  pendingFetchAbortController.abort();
}
const pendingReplies = /* @__PURE__ */ new Map();
let messageIdCounter = 0;
function sendAndWaitForReply(client, type, payload) {
  messageIdCounter += 1;
  const id = messageIdCounter;
  const promise = new Promise((resolve) => {
    pendingReplies.set(id, resolve);
  });
  client.postMessage({ type, id, payload });
  return promise;
}
async function findClient(predicate) {
  const clientList = await self.clients.matchAll({ type: "window" });
  for (const client of clientList) {
    if (await predicate(client)) {
      return client;
    }
  }
}
//# sourceMappingURL=sw.js.map
